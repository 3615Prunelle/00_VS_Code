/*Ce fichier tasks.json est utilisé par VS Code pour automatiser la compilation des fichiers C
via des tâches. Il définit plusieurs tâches de compilation qui peuvent être exécutées avant
le lancement du programme (comme défini dans launch.json).
Chaque tâche est une commande shell ou système qui exécute un compilateur (gcc, clang ou cc)
avec différents paramètres.
-----------
Explication des clés principales :
- tasks				Liste des différentes tâches de compilation.
- type				Type de tâche (ex. cppbuild pour la compilation C/C++).
- label				Nom de la tâche, utilisé pour l'exécuter depuis VS Code.
- command			Commande exécutée (ex. /usr/bin/gcc ou clang).
- args				Liste des arguments passés à la commande.
- options.cwd		Répertoire où la commande est exécutée.
- problemMatcher	Permet à VS Code d'afficher les erreurs de compilation.
- group				Définit si la tâche est une tâche de compilation principale.
- detail			Indique que la tâche a été générée automatiquement par le debugger.
*/
{
	"tasks": [
		{
			"type": "cppbuild",								// Tache 1
			"label": "C/C++: gcc build active file",
			"command": "/usr/bin/gcc",						// Utilise gcc pour compiler le fichier C actuellement ouvert (${file})
			"args": [
				"-g",										//Ajoute le flag -g pour inclure des informations de débogage
				"${file}",
				"-o",
				"${fileDirname}/${fileBasenameNoExtension}"	//Produit un exécutable portant le même nom que le fichier source dans le même dossier
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"										//Associe VS Code au détecteur d'erreurs de GCC
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation la plus basique, utile pour compiler et exécuter un seul fichier C sans créer de projet plus complexe ---- //
		{
			"label": "build",				// Tache 2 - Compilation spécifique pour get_next_line.c
			"command": "clang",				// Utilise clang pour compiler, au lieu de gcc
			"args": [
				"get_next_line.c",			//Compile uniquement get_next_line.c et get_next_line_utils.c
				"get_next_line_utils.c",
				"-g"						//Ajoute -g pour inclure les informations de débogage
			],
			"type": "shell",
			"presentation": {
				"echo": true,
				"reveal": "always",
				"panel": "shared"
			},
			"problemMatcher": {
				"owner": "c",
				"fileLocation": [
					"relative",
					"${workspaceRoot}"
				],
				"pattern": {			//Personnalise l'affichage des erreurs avec une regex qui capture les erreurs et avertissements
					"regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",
					"file": 1,
					"line": 2,
					"column": 3,
					"severity": 4,
					"message": 5
				}
			}
		},
//--------- Sum up : Compilation spécifique pour tester get_next_line sans compiler d'autres fichiers du projet ----------------- //
		{
			"type": "cppbuild",						// Tache 3
			"label": "C/C++: cc build active file",
			"command": "/usr/bin/cc",				// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"${file}",
				"-o",
				"${workspaceFolder}/a.out",			// Génère un exécutable a.out dans le dossier racine
				// "-Wall",							// Active tous les avertissements de base
				// "-Wextra",						// Active des avertissements supplémentaires
				// "-Werror",						// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation stricte, utile pour respecter les normes de code propres et éviter les erreurs potentielles ---- //
		{
			"type": "cppbuild",								// Tache 4
			"label": "C/C++: cc build active file bsd",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"${file}",
				"-o",
				"${workspaceFolder}/a.out",
				"-Wall",
				"-Wextra",
				"-Werror",
				"-DLIBBSD_OVERLAY",							// Ajoute -DLIBBSD_OVERLAY (définit une macro pour BSD)
				"-I/usr/include/bsd",						// Ajoute les headers de la bibliothèque bsd
				"-lbsd",									// Linke la bibliothèque bsd (-lbsd)
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Même chose que la précédente, mais compilations adaptées à BSD et à certains outils utilisant libbsd ------- //
		{
			"type": "cppbuild",						// Tache 5
			"label": "My LibFt library",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"ft_*.c",							// Compile tous les fichiers ft_*.c
				"-o",
				"${workspaceFolder}/a.out",
				// "-Wall",							// Active tous les avertissements de base
				// "-Wextra",						// Active des avertissements supplémentaires
				// "-Werror",						// Traite les avertissements comme des erreurs
				"-DLIBBSD_OVERLAY",
				"-I/usr/include/bsd",				// Ajoute les headers bsd et bibliothèques bsd (idem ligne suivante)
				//"-lbsd",							// -l permet d'inclure une library
				"-I${workspaceFolder}/libft",		// -I = Ajoute un nouveau répertoire à aller scanner pour chercher les include (les .h)
				"-L${workspaceFolder}/libft",		// -L = Ajoute un répertoire à aller scanner pour aller chercher des librairy (.a ou .so)
				//"-lft"							// Liaison avec libft.a (mais la ligne "-lft" est commentée)
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compile et linke LibFt (essentiel pour tester des projets 42) ---------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C: cc build ft_printf",
			"command": "/usr/bin/cc",		// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"ft_printf.c", "ft_printf_common_specifiers.c", "ft_printf_hexa_specifiers.c",
				"-o",
				"${workspaceFolder}/a.out",			//Génère un exécutable a.out dans le dossier racine
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-lft"							// Liaison avec libft.a (mais la ligne "-lft" est commentée)
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation pour Printf (en faire aussi une via Makefile sinon ?) ------------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build get_next_line",
			"command": "/usr/bin/cc",		// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"get_next_line.c", "get_next_line_utils.c", "main.c",	// Compile ces fichiers ensemble. (.h pris automatiquement en compte dans le header (include "GNL.h"))
				//line dessous créée pour tester le bonus, décommenter la partie qui m'intéresse
				//"get_next_line_bonus.c", "get_next_line_utils_bonus.c",
				"-D",													// Un argument par quote, donc ici on met -D et BUFFER_SIZE sur 2 lignes differentes
				"BUFFER_SIZE=10",
				//"-DROUQUINETTE_DEBUG", // mis dans fonction instead, sinon main grisee
				"-o",
				"${workspaceFolder}/a.out",								//Génère un exécutable a.out dans le dossier racine
				// "-Wall",												// Active tous les avertissements de base
				// "-Wextra",											// Active des avertissements supplémentaires
				// "-Werror",											// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation stricte pour GNL ------------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build so_long",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"so_long_main_build.c",		// Fichiers à compiler ensemble (les autres projets sont ajoutés différemment plus bas)
				"so_long_graphics.c",
				"so_long_checkers.c",
				"so_long_misc.c",
				"so_long_free_functions.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-I${workspaceFolder}/MLX42/include",	// Idem - Note : MLX42 n'est pas dans le répertoire mentionné ci dessus donc je le rajoute ici

				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/4_So_Long/",		// Idem - Note : So_Long n'a pas encore de library car WIP, donc je l'ajoute séparément

				//"-DROUQUINETTE_DEBUG",		// Trick super badass si besoin
				"-o",
				"${workspaceFolder}/a.out",		// Génère un exécutable a.out dans le dossier racine (00VSCode)
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lmlx42",						// Commandes necessaires pour utiliser MLX42 (this line + below)
				"-lglfw",						// Goes with mlx42 lib
				"-lgetnextline",				// A chaque nouveau .a/.h, penser à bien ajouter une ligne au dessus de celle-ci. Penser à compiler ce projet avant de tester dans VSCode
				"-lftprintf",
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation stricte pour so_long --------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build push_swap",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"push_swap_main.c",
				"push_swap_input_management.c",
				"push_swap_operations.c",
				"push_swap_others.c",
				"push_swap_algorithms.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/5_Push_Swap/",	// Pour la library du projet en cours
				"-o",
				"${workspaceFolder}/a.out",		// Génère un exécutable a.out dans le dossier racine
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lftprintf",					// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci. Penser à compiler le projet avant de tester dans VSCode
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Sum up : Compilation stricte pour push_swap ------------------------------------------------------------------------- //
		{
			"label": "Build with Makefile for So_Long",
			"type": "shell",
			"command": "make",
//			"args": [],				// Par défaut, commande make. Ajouter ["fclean"] ou autre si nécessaire
			"args": ["re"],
			"options": {
				"cwd": "${workspaceFolder}/4_So_Long",	// Localisation du Makefile
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Sum up : Compil through Makefile pour So-Long ----------------------------------------------------------------------- //
		{
			"label": "Build with Makefile for Push_Swap",
			"type": "shell",
			"command": "make",
			"args": ["re"],				// Par défaut, commande make. Ajouter ["re] ou autre si nécessaire
			"options": {
				"cwd": "${workspaceFolder}/5_Push_Swap"		// Localisation du Makefile
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Sum up : Compil through Makefile pour Push_Swap --------------------------------------------------------------------- //
		{
			"label": "C/C++: cc build minitalk server",
			"type": "shell",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"minitalk_server_main.c",
				"minitalk_binary_conversions.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/6_Minitalk/",	// Pour la library du projet en cours
				//"-DROUQUINETTE_DEBUG",		// Trick super badass si besoin
				"-o",
				"${workspaceFolder}/6_Minitalk/server",		// Path de l'exécutable
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lftprintf",					// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci. Penser à compiler le projet avant de tester dans VSCode
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${workspaceFolder}/6_Minitalk"
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Sum up : Compil pour Minitalk Server --------------------------------------------------------------------- //
		{
			"label": "C/C++: cc build minitalk client",
			"type": "shell",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"minitalk_client_main.c",
				"minitalk_binary_conversions.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/../00_VS_Code/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/../00_VS_Code/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/6_Minitalk/",	// Pour la library du projet en cours
				//"-DROUQUINETTE_DEBUG",		// Trick super badass si besoin
				"-o",
				"${workspaceFolder}/6_Minitalk/client",		// Path de l'exécutable
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lftprintf",					// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci. Penser à compiler le projet avant de tester dans VSCode
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${workspaceFolder}/6_Minitalk"
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Sum up : Compil pour Minitalk Client --------------------------------------------------------------------- //
],
	"version": "2.0.0"
}
